# Document de Correction - Page Anime-Sama

**Date**: 24 juin 2025  
**Version**: Corrections post-migration Replit  
**API Cible**: http://localhost:5000 (d√©veloppement) / https://votre-app.onrender.com (production)

## üö® PROBL√àME CRITIQUE 1: S√©lection de Langue Bugg√©e

**SYMPT√îME**: Quand vous changez de VF √† VOSTFR (ou vice versa), l'ancienne langue continue de jouer.

**DIAGNOSTIC**: L'API retourne bien des URLs diff√©rentes pour chaque langue (VF: `vjmxc1jxhw8f`, VOSTFR: `j2ect4ptgep1`). Le bug est dans le cache frontend qui garde l'ancienne langue.

**CORRECTIONS URGENTES**:

### A. Vider Cache Complet au Changement de Langue
```javascript
const handleLanguageChange = async (newLanguage) => {
  console.log(`Changement langue: ${selectedLanguage} -> ${newLanguage}`);
  
  // CRITIQUE: Vider tout le cache d'√©pisodes
  if (episodeCache) {
    episodeCache.clear();
  }
  
  // Vider le localStorage de cache
  Object.keys(localStorage).forEach(key => {
    if (key.includes('episode') || key.includes('anime')) {
      localStorage.removeItem(key);
    }
  });
  
  // R√©initialiser √©tat du lecteur
  setCurrentEpisode(null);
  setVideoSrc('');
  setEpisodes([]);
  
  // Attendre un d√©lai pour √©viter race conditions
  await new Promise(resolve => setTimeout(resolve, 200));
  
  // Mettre √† jour la langue
  setSelectedLanguage(newLanguage);
  
  // Recharger les √©pisodes avec nouvelle langue
  if (selectedAnime && selectedSeason) {
    await loadEpisodes(selectedAnime.id, selectedSeason, newLanguage);
  }
};
```

### B. Construction ID √âpisode avec Langue
```javascript
// PROBL√àME: L'ID d'√©pisode ne change pas avec la langue
// SOLUTION: Toujours inclure la langue dans l'ID

const buildEpisodeIdWithLanguage = (animeId, episodeNumber, language, season = null) => {
  const langCode = language.toLowerCase(); // 'vf' ou 'vostfr'
  
  if (season && season > 1) {
    return `${animeId}-saison${season}-episode-${episodeNumber}-${langCode}`;
  }
  return `${animeId}-episode-${episodeNumber}-${langCode}`;
};

// Usage avec protection
const loadEpisodeWithLanguage = async (animeId, episodeNumber, language) => {
  const episodeId = buildEpisodeIdWithLanguage(animeId, episodeNumber, language);
  
  console.log(`Chargement √©pisode avec langue: ${episodeId}`);
  
  // Force reload sans cache
  const response = await fetch(`${API_BASE_URL}/api/episode/${episodeId}?lang=${language}&_=${Date.now()}`);
  const data = await response.json();
  
  return data;
};
```

### C. State Management S√©par√© par Langue
```javascript
// PROBL√àME: Un seul √©tat pour toutes les langues
// SOLUTION: √âtat s√©par√© par langue

const [episodesByLanguage, setEpisodesByLanguage] = useState({
  VF: {},
  VOSTFR: {}
});

const [currentVideoByLanguage, setCurrentVideoByLanguage] = useState({
  VF: null,
  VOSTFR: null
});

const switchLanguage = async (newLanguage) => {
  // Sauvegarder l'√©tat actuel
  if (currentEpisode && videoSrc) {
    setCurrentVideoByLanguage(prev => ({
      ...prev,
      [selectedLanguage]: {
        episode: currentEpisode,
        videoSrc: videoSrc
      }
    }));
  }
  
  // Changer la langue
  setSelectedLanguage(newLanguage);
  
  // Restaurer l'√©tat pour la nouvelle langue
  const savedState = currentVideoByLanguage[newLanguage];
  if (savedState) {
    setCurrentEpisode(savedState.episode);
    setVideoSrc(savedState.videoSrc);
  } else {
    // Premi√®re fois dans cette langue, recharger
    setCurrentEpisode(null);
    setVideoSrc('');
    await loadEpisodesForLanguage(newLanguage);
  }
};
```

### D. Debounce Anti-Race pour Changement Langue
```javascript
let languageChangeTimeout = null;

const debouncedLanguageChange = (newLanguage) => {
  // Annuler changement pr√©c√©dent
  if (languageChangeTimeout) {
    clearTimeout(languageChangeTimeout);
  }
  
  // Nouveau changement avec d√©lai
  languageChangeTimeout = setTimeout(async () => {
    await performLanguageChange(newLanguage);
  }, 300); // 300ms de d√©lai
};

const performLanguageChange = async (newLanguage) => {
  if (newLanguage === selectedLanguage) {
    console.log('M√™me langue, ignore');
    return;
  }
  
  console.log(`Changement d√©finitif: ${selectedLanguage} -> ${newLanguage}`);
  
  // Vider tout cache li√© √† l'ancienne langue
  clearLanguageCache(selectedLanguage);
  
  // Effectuer le changement
  await handleLanguageChange(newLanguage);
};
```

## üö® PROBL√àME CRITIQUE 2: Mauvais √âpisode Jou√©

**‚ùå SYMPT√îME**: Quand vous s√©lectionnez un √©pisode, ce n'est pas le bon √©pisode qui se lit dans le lecteur.

**üîç DIAGNOSTIC**: L'API fonctionne correctement et retourne les bonnes URLs d'√©pisode (v√©rifi√©s: √©pisode 1, 5 et 10 ont des URLs uniques). Le probl√®me est dans le frontend - probablement cache d'√©pisode ou mauvaise gestion d'√©tat.

**‚úÖ CORRECTIONS URGENTES**:

### A. Cache d'√âpisode Bugg√©
```javascript
// PROBL√àME: Cache qui garde les anciennes donn√©es d'√©pisode
// SOLUTION: Vider le cache √† chaque changement d'√©pisode

const loadEpisode = async (episodeId) => {
  // CRITIQUE: Vider le cache avant de charger un nouvel √©pisode
  if (episodeCache) {
    episodeCache.delete(episodeId);
    episodeCache.delete(`episode-${episodeId}`);
    // Vider aussi les cl√©s similaires
    for (const [key] of episodeCache.entries()) {
      if (key.includes(episodeId.split('-')[0])) {
        episodeCache.delete(key);
      }
    }
  }
  
  // Forcer rechargement depuis API
  const response = await fetch(`${API_BASE_URL}/api/episode/${episodeId}?_=${Date.now()}`);
  const data = await response.json();
  
  if (data.success && data.data.sources.length > 0) {
    // CRITIQUE: Utiliser embedUrl qui garantit le bon √©pisode
    const embedUrl = `${API_BASE_URL}${data.data.sources[0].embedUrl}`;
    
    // Vider l'iframe avant de charger le nouveau
    if (videoIframe) {
      videoIframe.src = 'about:blank';
      await new Promise(resolve => setTimeout(resolve, 100)); // Attendre 100ms
    }
    
    videoIframe.src = embedUrl;
    
    console.log(`√âpisode charg√©: ${episodeId} -> ${embedUrl}`);
  }
};
```

### B. √âtat React Conflictuel
```javascript
// PROBL√àME: √âtat React qui ne se met pas √† jour correctement
// SOLUTION: R√©initialiser compl√®tement l'√©tat

const [currentEpisode, setCurrentEpisode] = useState(null);
const [videoSrc, setVideoSrc] = useState('');
const [lastEpisodeId, setLastEpisodeId] = useState('');

const handleEpisodeClick = async (episode) => {
  // CRITIQUE: V√©rifier si ce n'est pas d√©j√† l'√©pisode en cours
  if (lastEpisodeId === episode.id && videoSrc) {
    console.log('√âpisode d√©j√† charg√©:', episode.id);
    return;
  }
  
  // R√©initialiser compl√®tement l'√©tat
  setCurrentEpisode(null);
  setVideoSrc('');
  setLoading(true);
  
  try {
    // Charger les d√©tails de l'√©pisode
    const response = await fetch(`${API_BASE_URL}/api/episode/${episode.id}`);
    const data = await response.json();
    
    if (data.success && data.data.sources.length > 0) {
      const newVideoSrc = `${API_BASE_URL}${data.data.sources[0].embedUrl}`;
      
      // CRITIQUE: Mettre √† jour l'√©tat dans le bon ordre
      setCurrentEpisode(episode);
      setVideoSrc(newVideoSrc);
      setLastEpisodeId(episode.id);
      
      console.log(`Nouvel √©pisode: ${episode.id} -> ${newVideoSrc}`);
    }
  } catch (error) {
    console.error('Erreur chargement √©pisode:', error);
  } finally {
    setLoading(false);
  }
};
```

### C. URL d'√âpisode Incorrecte
```javascript
// PROBL√àME: Construction d'URL d'√©pisode inconsistante
// SOLUTION: Utiliser exactement le m√™me format que l'API

const buildCorrectEpisodeId = (animeId, episodeNumber, language, seasonNumber = null) => {
  // CRITIQUE: Format exact selon l'API
  if (seasonNumber && seasonNumber > 1) {
    return `${animeId}-saison${seasonNumber}-episode-${episodeNumber}-${language.toLowerCase()}`;
  }
  return `${animeId}-episode-${episodeNumber}-${language.toLowerCase()}`;
};

// Test avec My Hero Academia
const testEpisodeIds = [
  buildCorrectEpisodeId('my-hero-academia', 1, 'vostfr'),    // my-hero-academia-episode-1-vostfr
  buildCorrectEpisodeId('my-hero-academia', 5, 'vostfr'),    // my-hero-academia-episode-5-vostfr
  buildCorrectEpisodeId('my-hero-academia', 1, 'vostfr', 7), // my-hero-academia-saison7-episode-1-vostfr
];
```

### D. Race Condition dans le Lecteur
```javascript
// PROBL√àME: Plusieurs √©pisodes charg√©s en m√™me temps
// SOLUTION: Queue de chargement

let episodeLoadingQueue = null;

const loadEpisodeWithQueue = async (episodeId) => {
  // Annuler le chargement pr√©c√©dent
  if (episodeLoadingQueue) {
    episodeLoadingQueue.cancel = true;
  }
  
  // Cr√©er nouvelle t√¢che
  const currentTask = { cancel: false, episodeId };
  episodeLoadingQueue = currentTask;
  
  try {
    await new Promise(resolve => setTimeout(resolve, 100)); // D√©lai anti-race
    
    // V√©rifier si la t√¢che n'a pas √©t√© annul√©e
    if (currentTask.cancel) {
      console.log('Chargement √©pisode annul√©:', episodeId);
      return;
    }
    
    // Charger l'√©pisode
    const response = await fetch(`${API_BASE_URL}/api/episode/${episodeId}`);
    const data = await response.json();
    
    // V√©rifier encore si pas annul√©
    if (currentTask.cancel) {
      console.log('Chargement √©pisode annul√© apr√®s fetch:', episodeId);
      return;
    }
    
    // Mettre √† jour le lecteur
    if (data.success && data.data.sources.length > 0) {
      const embedUrl = `${API_BASE_URL}${data.data.sources[0].embedUrl}`;
      updateVideoPlayer(embedUrl, episodeId);
    }
    
  } catch (error) {
    if (!currentTask.cancel) {
      console.error('Erreur chargement √©pisode:', error);
    }
  }
};
```

## üö® Probl√®mes Identifi√©s et Corrections Requises

### 1. Configuration API Obsol√®te

**‚ùå PROBL√àME**: L'API configur√©e dans la documentation pointe vers `https://api-anime-sama.onrender.com` qui peut ne pas avoir les derni√®res corrections CORS.

**‚úÖ CORRECTION**:
```javascript
// Remplacer la configuration API actuelle par:
const API_BASE_URL = process.env.NODE_ENV === 'production' 
  ? 'https://votre-nouvelle-app.onrender.com'  // √Ä remplacer par votre URL Render
  : 'http://localhost:5000';  // Pour d√©veloppement local

// Headers CORS renforc√©s
const DEFAULT_HEADERS = {
  'Content-Type': 'application/json',
  'Accept': 'application/json',
  'Access-Control-Allow-Origin': '*',
  'X-Frame-Options': 'ALLOWALL'
};
```

### 2. Gestion CORS Iframe Insuffisante

**‚ùå PROBL√àME**: Le lecteur vid√©o affiche "anime-sama.fr n'autorise pas la connexion"

**‚úÖ CORRECTION**: Utiliser les nouveaux endpoints proxy
```javascript
// Dans la fonction de chargement vid√©o
const loadEpisodeVideo = async (episodeId) => {
  try {
    const response = await fetch(`${API_BASE_URL}/api/episode/${episodeId}`);
    const data = await response.json();
    
    if (data.success && data.data.sources.length > 0) {
      const source = data.data.sources[0];
      
      // NOUVEAU: Utiliser proxyUrl au lieu de l'URL directe
      const videoUrl = `${API_BASE_URL}${source.proxyUrl}`;
      
      // Ou utiliser l'endpoint embed d√©di√©
      const embedUrl = `${API_BASE_URL}${source.embedUrl}`;
      
      // Configurer l'iframe avec headers CORS
      iframe.src = embedUrl;  // Plus fiable que proxyUrl
      iframe.setAttribute('allowfullscreen', 'true');
      iframe.setAttribute('allow', 'autoplay; fullscreen');
    }
  } catch (error) {
    console.error('Erreur chargement vid√©o:', error);
    showErrorMessage('Impossible de charger la vid√©o. Essayez un autre serveur.');
  }
};
```

### 3. Endpoints Episode avec Saison Manquants

**‚ùå PROBL√àME**: Les appels d'√©pisode utilisent un format incorrect pour les saisons

**‚úÖ CORRECTION**: Ajuster le format des IDs d'√©pisode
```javascript
// ANCIEN format (incorrect)
const episodeId = `${animeId}-episode-${episodeNumber}-${language}`;

// NOUVEAU format (correct pour saisons)
const generateEpisodeId = (animeId, season, episode, language) => {
  if (season > 1) {
    return `${animeId}-saison${season}-episode-${episode}-${language}`;
  }
  return `${animeId}-episode-${episode}-${language}`;
};

// Exemple d'utilisation
const episodeId = generateEpisodeId('my-hero-academia', 7, 1, 'vostfr');
// R√©sultat: "my-hero-academia-saison7-episode-1-vostfr"
```

### 4. Gestion d'Erreur Race Conditions

**‚ùå PROBL√àME**: Changements de langue peuvent cr√©er des conflits

**‚úÖ CORRECTION**: Ajouter protection anti-race condition
```javascript
// Ajouter un flag de protection
let languageChangeInProgress = false;

const handleLanguageChange = async (newLanguage) => {
  // Protection contre les appels multiples
  if (languageChangeInProgress) {
    console.log('Changement de langue d√©j√† en cours...');
    return;
  }
  
  languageChangeInProgress = true;
  
  try {
    setLoading(true);
    setError(null);
    
    // Effectuer le changement
    await loadEpisodes(selectedAnime.id, selectedSeason, newLanguage.toLowerCase());
    setSelectedLanguage(newLanguage);
    
    // Sauvegarder la pr√©f√©rence
    localStorage.setItem('preferred_language', newLanguage);
    
  } catch (error) {
    console.error('Erreur changement langue:', error);
    setError(`Impossible de charger les √©pisodes en ${newLanguage}`);
    
    // Ne pas changer la langue en cas d'erreur
    // setSelectedLanguage reste inchang√©
    
  } finally {
    setLoading(false);
    languageChangeInProgress = false;
  }
};
```

### 5. Cache Non Optimis√©

**‚ùå PROBL√àME**: Le cache actuel ne g√®re pas les expirations proprement

**‚úÖ CORRECTION**: Impl√©menter un cache avec TTL
```javascript
class SmartCache {
  constructor(ttl = 300000) { // 5 minutes par d√©faut
    this.cache = new Map();
    this.ttl = ttl;
  }
  
  set(key, data) {
    this.cache.set(key, {
      data,
      timestamp: Date.now(),
      expires: Date.now() + this.ttl
    });
  }
  
  get(key) {
    const item = this.cache.get(key);
    if (!item) return null;
    
    if (Date.now() > item.expires) {
      this.cache.delete(key);
      return null;
    }
    
    return item.data;
  }
  
  clear() {
    this.cache.clear();
  }
  
  size() {
    return this.cache.size;
  }
}

// Utilisation
const episodeCache = new SmartCache(300000); // 5 minutes

const getEpisodesCached = async (animeId, season, language) => {
  const cacheKey = `${animeId}-${season}-${language}`;
  
  // V√©rifier le cache d'abord
  const cached = episodeCache.get(cacheKey);
  if (cached) {
    console.log('Donn√©es depuis cache:', cacheKey);
    return cached;
  }
  
  // Charger depuis API
  const data = await loadEpisodesFromAPI(animeId, season, language);
  
  // Mettre en cache
  episodeCache.set(cacheKey, data);
  
  return data;
};
```

### 6. Retry Logic Manquant

**‚ùå PROBL√àME**: Pas de gestion de retry en cas d'√©chec API

**‚úÖ CORRECTION**: Ajouter syst√®me de retry automatique
```javascript
const fetchWithRetry = async (url, options = {}, maxRetries = 3) => {
  let lastError;
  
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      console.log(`Tentative ${attempt}/${maxRetries}: ${url}`);
      
      const response = await fetch(url, {
        ...options,
        timeout: 20000  // 20 secondes
      });
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      return await response.json();
      
    } catch (error) {
      lastError = error;
      console.warn(`Tentative ${attempt} √©chou√©e:`, error.message);
      
      if (attempt < maxRetries) {
        const delay = Math.pow(2, attempt) * 1000; // D√©lai exponentiel
        console.log(`Retry dans ${delay}ms...`);
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
  }
  
  throw lastError;
};

// Utilisation dans vos appels API
const searchAnime = async (query) => {
  try {
    return await fetchWithRetry(`${API_BASE_URL}/api/search?query=${encodeURIComponent(query)}`);
  } catch (error) {
    console.error('Recherche √©chou√©e apr√®s tous les retries:', error);
    throw new Error('Impossible de rechercher les animes. V√©rifiez votre connexion.');
  }
};
```

### 7. URLs Episode Incorrectes

**‚ùå PROBL√àME**: Format d'URL d'√©pisode non conforme √† l'API

**‚úÖ CORRECTION**: Utiliser le bon format d'URL
```javascript
// Fonction pour construire l'URL d'√©pisode
const buildEpisodeUrl = (animeData, season, episodeNumber, language) => {
  const animeId = animeData.id;
  const seasonData = animeData.seasons.find(s => s.number === season);
  
  if (!seasonData) {
    throw new Error(`Saison ${season} non trouv√©e pour ${animeId}`);
  }
  
  // Format pour saison 1
  if (season === 1) {
    return `${animeId}-episode-${episodeNumber}-${language}`;
  }
  
  // Format pour autres saisons
  return `${animeId}-saison${season}-episode-${episodeNumber}-${language}`;
};

// Cas sp√©ciaux (si n√©cessaire)
const buildEpisodeUrlWithFallback = (animeData, season, episodeNumber, language) => {
  const patterns = [
    `${animeData.id}-saison${season}-episode-${episodeNumber}-${language}`,
    `${animeData.id}-s${season}e${episodeNumber}-${language}`,
    `${animeData.id}-${season}x${episodeNumber.toString().padStart(2, '0')}-${language}`,
    `${animeData.id}-episode-${episodeNumber}-${language}` // Fallback
  ];
  
  return patterns;
};
```

### 8. √âtat Loading Non Granulaire

**‚ùå PROBL√àME**: Un seul √©tat loading pour toute l'application

**‚úÖ CORRECTION**: √âtats loading granulaires
```javascript
const [loadingStates, setLoadingStates] = useState({
  search: false,
  anime: false,
  episodes: false,
  video: false
});

const setLoading = (type, isLoading) => {
  setLoadingStates(prev => ({
    ...prev,
    [type]: isLoading
  }));
};

// Utilisation
const searchAnime = async (query) => {
  setLoading('search', true);
  try {
    const results = await api.search(query);
    setSearchResults(results);
  } catch (error) {
    setError('Erreur de recherche');
  } finally {
    setLoading('search', false);
  }
};

const loadEpisodes = async (animeId, season, language) => {
  setLoading('episodes', true);
  try {
    const episodes = await api.getEpisodes(animeId, season, language);
    setEpisodes(episodes);
  } catch (error) {
    setError('Erreur chargement √©pisodes');
  } finally {
    setLoading('episodes', false);
  }
};
```

### 9. S√©lecteur de Serveur Manquant

**‚ùå PROBL√àME**: Pas de possibilit√© de changer de serveur vid√©o

**‚úÖ CORRECTION**: Ajouter s√©lecteur de serveur
```javascript
const VideoPlayer = ({ episodeId, sources }) => {
  const [selectedServerIndex, setSelectedServerIndex] = useState(0);
  const [videoError, setVideoError] = useState(false);
  
  const currentSource = sources[selectedServerIndex];
  
  const handleServerChange = (index) => {
    setSelectedServerIndex(index);
    setVideoError(false);
  };
  
  const handleVideoError = () => {
    setVideoError(true);
    
    // Auto-switch au serveur suivant
    if (selectedServerIndex < sources.length - 1) {
      console.log('Changement automatique vers serveur suivant');
      setSelectedServerIndex(prev => prev + 1);
    }
  };
  
  return (
    <div className="video-player">
      {/* S√©lecteur de serveur */}
      <div className="server-selector">
        <label>Serveur:</label>
        {sources.map((source, index) => (
          <button
            key={index}
            className={`server-btn ${index === selectedServerIndex ? 'active' : ''}`}
            onClick={() => handleServerChange(index)}
            disabled={!source.url}
          >
            {source.server} ({source.quality})
            {index === selectedServerIndex && videoError && ' ‚ùå'}
          </button>
        ))}
      </div>
      
      {/* Lecteur vid√©o */}
      <div className="video-container">
        {videoError ? (
          <div className="error-message">
            Erreur de lecture. Essayez un autre serveur.
          </div>
        ) : (
          <iframe
            src={`${API_BASE_URL}${currentSource.embedUrl}`}
            onError={handleVideoError}
            allowFullScreen
            allow="autoplay; fullscreen"
          />
        )}
      </div>
    </div>
  );
};
```

### 10. Configuration Responsive Manquante

**‚ùå PROBL√àME**: Interface non optimis√©e mobile

**‚úÖ CORRECTION**: Ajouter styles responsive
```css
/* Responsive design pour mobile */
@media (max-width: 768px) {
  .anime-container {
    padding: 10px;
  }
  
  .search-bar {
    width: 100%;
    margin-bottom: 20px;
  }
  
  .episode-grid {
    grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
    gap: 10px;
  }
  
  .video-player iframe {
    height: 200px;
  }
  
  .server-selector {
    flex-wrap: wrap;
    gap: 5px;
  }
  
  .server-btn {
    font-size: 12px;
    padding: 5px 8px;
  }
  
  .language-selector {
    flex-direction: column;
    align-items: stretch;
  }
}

/* Mode paysage mobile */
@media (orientation: landscape) and (max-height: 500px) {
  .video-player iframe {
    height: 300px;
  }
}
```

## üîÑ Plan de Migration √âtape par √âtape

### √âtape 1: Mise √† jour Configuration API
1. Changer l'URL de base API vers votre instance Render
2. Ajouter les nouveaux headers CORS
3. Impl√©menter le syst√®me de retry

### √âtape 2: Correction Lecteur Vid√©o
1. Remplacer les URLs directes par embedUrl
2. Ajouter le s√©lecteur de serveur
3. Impl√©menter la gestion d'erreur vid√©o

### √âtape 3: Optimisation Cache et Performance
1. Impl√©menter SmartCache avec TTL
2. Ajouter √©tats loading granulaires
3. Optimiser les appels API

### √âtape 4: Corrections UX
1. Ajouter protection race conditions
2. Am√©liorer gestion d'erreurs
3. Ajouter responsive design

### √âtape 5: Tests et Validation
1. Tester tous les animes populaires
2. V√©rifier compatibilit√© mobile
3. Valider performance cache

## üß™ Test Changement de Langue

Testez sp√©cifiquement le changement de langue :

```javascript
const testLanguageSwitch = async () => {
  console.log('üß™ Test changement VF/VOSTFR');
  
  const testCases = [
    { episodeNumber: 1, vf: 'my-hero-academia-episode-1-vf', vostfr: 'my-hero-academia-episode-1-vostfr' },
    { episodeNumber: 5, vf: 'my-hero-academia-episode-5-vf', vostfr: 'my-hero-academia-episode-5-vostfr' }
  ];
  
  for (const testCase of testCases) {
    console.log(`Test √©pisode ${testCase.episodeNumber}:`);
    
    // Test VF
    const vfResponse = await fetch(`${API_BASE_URL}/api/episode/${testCase.vf}`);
    const vfData = await vfResponse.json();
    
    // Test VOSTFR
    const vostfrResponse = await fetch(`${API_BASE_URL}/api/episode/${testCase.vostfr}`);
    const vostfrData = await vostfrResponse.json();
    
    if (vfData.success && vostfrData.success) {
      const vfUrl = vfData.data.sources[0].url;
      const vostfrUrl = vostfrData.data.sources[0].url;
      
      console.log(`√âpisode ${testCase.episodeNumber} VF: ${vfUrl}`);
      console.log(`√âpisode ${testCase.episodeNumber} VOSTFR: ${vostfrUrl}`);
      
      // V√©rifier que les URLs sont diff√©rentes
      if (vfUrl === vostfrUrl) {
        console.error(`‚ùå ERREUR: M√™me URL pour VF et VOSTFR !`);
      } else {
        console.log(`‚úÖ URLs diff√©rentes pour VF/VOSTFR`);
      }
      
      // Extraire identifiants uniques
      const vfId = vfUrl.split('/').pop();
      const vostfrId = vostfrUrl.split('/').pop();
      console.log(`VF ID: ${vfId}, VOSTFR ID: ${vostfrId}`);
    }
    
    console.log('---');
  }
};

// Lancer le test
testLanguageSwitch();
```

## üîß D√©bogage Changement Langue

Ajoutez ces logs pour traquer les changements de langue :

```javascript
const debugLanguageChange = (oldLang, newLang, episodeId) => {
  console.log(`üåê CHANGEMENT LANGUE`);
  console.log(`üåê Ancienne: ${oldLang}`);
  console.log(`üåê Nouvelle: ${newLang}`);
  console.log(`üåê √âpisode: ${episodeId}`);
  console.log(`üåê Cache avant:`, episodeCache.size());
  console.log(`üåê √âtat vid√©o avant:`, videoIframe?.src);
  console.log(`üåê Timestamp:`, new Date().toISOString());
  
  // Apr√®s changement
  setTimeout(() => {
    console.log(`üåê Cache apr√®s:`, episodeCache.size());
    console.log(`üåê √âtat vid√©o apr√®s:`, videoIframe?.src);
    console.log(`üåê CHANGEMENT TERMIN√â`);
  }, 1000);
};
```

## üß™ Test de Correspondance √âpisode

Ajoutez ce code de test pour v√©rifier que le bon √©pisode se charge :

```javascript
const testEpisodeCorrespondence = async () => {
  console.log('üß™ Test correspondance √©pisode/vid√©o');
  
  const testCases = [
    { episodeId: 'my-hero-academia-episode-1-vostfr', expectedEpisode: 1 },
    { episodeId: 'my-hero-academia-episode-5-vostfr', expectedEpisode: 5 },
    { episodeId: 'my-hero-academia-episode-10-vostfr', expectedEpisode: 10 }
  ];
  
  for (const testCase of testCases) {
    try {
      console.log(`Test √©pisode ${testCase.expectedEpisode}...`);
      
      // Charger l'√©pisode
      const response = await fetch(`${API_BASE_URL}/api/episode/${testCase.episodeId}`);
      const data = await response.json();
      
      if (data.success && data.data.sources.length > 0) {
        const url = data.data.sources[0].url;
        console.log(`√âpisode ${testCase.expectedEpisode}: ${url}`);
        
        // V√©rifier que l'URL est unique (pas de cache bugg√©)
        const urlHash = url.split('/').pop();
        console.log(`Hash unique: ${urlHash}`);
        
        // Simuler le chargement dans iframe
        const embedUrl = `${API_BASE_URL}${data.data.sources[0].embedUrl}`;
        console.log(`Iframe URL: ${embedUrl}`);
        
      } else {
        console.error(`‚ùå Pas de sources pour √©pisode ${testCase.expectedEpisode}`);
      }
    } catch (error) {
      console.error(`‚ùå Erreur test √©pisode ${testCase.expectedEpisode}:`, error);
    }
  }
  
  console.log('üéâ Test termin√© - v√©rifiez que chaque √©pisode a une URL unique');
};

// Lancer le test
testEpisodeCorrespondence();
```

## üîß D√©bogage en Temps R√©el

Ajoutez ces logs dans votre page pour identifier le probl√®me :

```javascript
// Dans votre fonction de chargement d'√©pisode
const loadEpisode = async (episodeId) => {
  console.log(`üé¨ D√âBUT chargement √©pisode: ${episodeId}`);
  console.log(`üé¨ Timestamp: ${new Date().toISOString()}`);
  
  const response = await fetch(`${API_BASE_URL}/api/episode/${episodeId}`);
  const data = await response.json();
  
  if (data.success) {
    const url = data.data.sources[0].url;
    const embedUrl = data.data.sources[0].embedUrl;
    
    console.log(`üé¨ URL re√ßue: ${url}`);
    console.log(`üé¨ Embed URL: ${embedUrl}`);
    console.log(`üé¨ Hash unique: ${url.split('/').pop()}`);
    
    // V√©rifier si l'iframe change vraiment
    const currentIframeSrc = videoIframe.src;
    const newIframeSrc = `${API_BASE_URL}${embedUrl}`;
    
    console.log(`üé¨ Iframe actuelle: ${currentIframeSrc}`);
    console.log(`üé¨ Nouvelle iframe: ${newIframeSrc}`);
    console.log(`üé¨ Changement: ${currentIframeSrc !== newIframeSrc ? 'OUI' : 'NON'}`);
    
    videoIframe.src = newIframeSrc;
    
    console.log(`üé¨ FIN chargement √©pisode: ${episodeId}`);
  }
};
```

## üß™ Code de Test

```javascript
// Test complet de l'int√©gration
const testAnimeIntegration = async () => {
  console.log('üß™ Test int√©gration Anime-Sama');
  
  try {
    // Test 1: Recherche
    console.log('Test recherche...');
    const searchResults = await searchAnime('my hero academia');
    console.log('‚úÖ Recherche OK:', searchResults.length, 'r√©sultats');
    
    // Test 2: D√©tails anime
    console.log('Test d√©tails anime...');
    const animeDetails = await getAnimeDetails(searchResults[0].id);
    console.log('‚úÖ D√©tails OK:', animeDetails.title);
    
    // Test 3: √âpisodes
    console.log('Test √©pisodes...');
    const episodeId = generateEpisodeId('my-hero-academia', 7, 1, 'vostfr');
    const episodeDetails = await getEpisodeDetails(episodeId);
    console.log('‚úÖ √âpisodes OK:', episodeDetails.sources.length, 'sources');
    
    // Test 4: Lecteur
    console.log('Test lecteur...');
    const embedUrl = episodeDetails.sources[0].embedUrl;
    console.log('‚úÖ Lecteur OK:', embedUrl);
    
    console.log('üéâ Tous les tests pass√©s!');
    
  } catch (error) {
    console.error('‚ùå Test √©chou√©:', error);
  }
};

// Lancer le test
testAnimeIntegration();
```

## üìù R√©sum√© des Corrections

1. **‚úÖ Configuration API mise √† jour** avec votre instance Render
2. **‚úÖ Correction CORS iframe** avec embedUrl et proxyUrl  
3. **‚úÖ Format √©pisode corrig√©** pour les saisons multiples
4. **‚úÖ Protection race conditions** pour changements langue
5. **‚úÖ Cache intelligent** avec TTL et expiration
6. **‚úÖ Syst√®me retry** avec d√©lai exponentiel
7. **‚úÖ √âtats loading granulaires** pour meilleure UX
8. **‚úÖ S√©lecteur serveur** avec fallback automatique
9. **‚úÖ Design responsive** pour mobile
10. **‚úÖ Tests complets** pour validation

Avec ces corrections, votre page anime-sama fonctionnera parfaitement avec l'API migr√©e sur Render.